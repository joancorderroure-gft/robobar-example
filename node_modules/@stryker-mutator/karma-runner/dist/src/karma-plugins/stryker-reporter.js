"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StrykerReporter = exports.strykerReporterFactory = void 0;
const test_runner_1 = require("@stryker-mutator/api/test-runner");
const util_1 = require("@stryker-mutator/util");
function strykerReporterFactory(karmaServer, config) {
    StrykerReporter.instance.karmaServer = karmaServer;
    StrykerReporter.instance.karmaConfig = config;
    return StrykerReporter.instance;
}
exports.strykerReporterFactory = strykerReporterFactory;
strykerReporterFactory.$inject = ['server', 'config'];
/**
 * This is a singleton implementation of a KarmaReporter.
 * It is loaded by karma and functions as a bridge between the karma world and the stryker world
 *
 * It uses properties as functions because karma is not able to find actual methods.
 *
 * i.e. use `public readonly onFoo = () => {}` instead of `onFoo() { }`.
 */
class StrykerReporter {
    constructor() {
        this.adapters = [];
        this.testResults = [];
        this.browserIsRestarting = false;
        this.onBrowsersReady = () => {
            var _a, _b;
            (_a = this.initTask) === null || _a === void 0 ? void 0 : _a.resolve();
            (_b = this.runTask) === null || _b === void 0 ? void 0 : _b.resolve(this.collectRunResult());
        };
        this.onSpecComplete = (_browser, spec) => {
            const name = spec.suite.reduce((specName, suite) => specName + suite + ' ', '') + spec.description;
            const id = spec.id || name;
            if (spec.skipped) {
                this.testResults.push({
                    id,
                    name,
                    timeSpentMs: spec.time,
                    status: test_runner_1.TestStatus.Skipped,
                });
            }
            else if (spec.success) {
                this.testResults.push({
                    id,
                    name,
                    timeSpentMs: spec.time,
                    status: test_runner_1.TestStatus.Success,
                });
            }
            else {
                this.testResults.push({
                    id,
                    name,
                    timeSpentMs: spec.time,
                    status: test_runner_1.TestStatus.Failed,
                    failureMessage: spec.log.join(', '),
                });
            }
        };
        this.onRunStart = () => {
            this.testResults = [];
            this.errorMessage = undefined;
            this.mutantCoverage = undefined;
            this.karmaRunResult = undefined;
            this.browserIsRestarting = false;
        };
        this.onRunComplete = (_browsers, runResult) => {
            this.karmaRunResult = runResult;
            if (!this.browserIsRestarting) {
                this.runTask.resolve(this.collectRunResult());
            }
        };
        this.onBrowserComplete = (_browser, result) => {
            this.mutantCoverage = result.mutantCoverage;
            this.hitCount = result.hitCount;
        };
        // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
        this.onBrowserError = (browser, error) => {
            if (this.initTask) {
                this.initTask.reject(error);
            }
            else {
                if (browser.state.toUpperCase().includes('DISCONNECTED')) {
                    // Restart the browser for next run
                    this.karmaServer.get('launcher').restart(browser.id);
                    this.browserIsRestarting = true;
                }
                // Karma 2.0 has different error messages
                if (error.message) {
                    this.errorMessage = error.message;
                }
                else {
                    this.errorMessage = error.toString();
                }
            }
        };
    }
    static get instance() {
        return this._instance;
    }
    configureHitLimit(hitLimit) {
        this.hitLimit = hitLimit;
        this.hitCount = undefined;
    }
    whenBrowsersReady() {
        this.initTask = new util_1.Task();
        return this.initTask.promise.finally(() => {
            this.initTask = undefined;
        });
    }
    whenRunCompletes() {
        this.runTask = new util_1.Task();
        return this.runTask.promise.finally(() => {
            this.runTask = undefined;
        });
    }
    collectRunResult() {
        var _a, _b, _c;
        const timeoutResult = (0, test_runner_1.determineHitLimitReached)(this.hitCount, this.hitLimit);
        if (timeoutResult) {
            return timeoutResult;
        }
        if ((_a = this.karmaRunResult) === null || _a === void 0 ? void 0 : _a.disconnected) {
            return { status: test_runner_1.DryRunStatus.Timeout, reason: `Browser disconnected during test execution. Karma error: ${this.errorMessage}` };
        }
        else if ((_b = this.karmaRunResult) === null || _b === void 0 ? void 0 : _b.error) {
            return { status: test_runner_1.DryRunStatus.Error, errorMessage: (_c = this.errorMessage) !== null && _c !== void 0 ? _c : 'A runtime error occurred' };
        }
        else {
            return { status: test_runner_1.DryRunStatus.Complete, tests: this.testResults, mutantCoverage: this.mutantCoverage };
        }
    }
}
exports.StrykerReporter = StrykerReporter;
StrykerReporter._instance = new StrykerReporter();
//# sourceMappingURL=stryker-reporter.js.map