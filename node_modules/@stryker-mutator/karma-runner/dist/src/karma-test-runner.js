"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KarmaTestRunner = void 0;
const tslib_1 = require("tslib");
const plugin_1 = require("@stryker-mutator/api/plugin");
const test_runner_1 = require("@stryker-mutator/api/test-runner");
const karma_wrapper_1 = require("./karma-wrapper");
const stryker_karma_conf_1 = (0, tslib_1.__importDefault)(require("./starters/stryker-karma.conf"));
const project_starter_1 = require("./starters/project-starter");
const stryker_reporter_1 = require("./karma-plugins/stryker-reporter");
const test_hooks_middleware_1 = require("./karma-plugins/test-hooks-middleware");
class KarmaTestRunner {
    constructor(log, getLogger, options) {
        this.log = log;
        const setup = this.loadSetup(options);
        this.starter = new project_starter_1.ProjectStarter(getLogger, setup);
        stryker_karma_conf_1.default.setGlobals({
            getLogger,
            karmaConfig: setup.config,
            karmaConfigFile: setup.configFile,
            disableBail: options.disableBail,
        });
    }
    async init() {
        const browsersReadyPromise = stryker_reporter_1.StrykerReporter.instance.whenBrowsersReady();
        const { exitPromise } = await this.starter.start();
        this.exitPromise = exitPromise;
        const maybeExitCode = await Promise.race([browsersReadyPromise, exitPromise]);
        if (typeof maybeExitCode === 'number') {
            throw new Error(`Karma exited prematurely with exit code ${maybeExitCode}. Please run stryker with \`--logLevel trace\` to see the karma logging and figure out what's wrong.`);
        }
        else {
            // Create new run config. Older versions of karma will always parse the config again when you provide it in `karma.runner.run
            // which results in the karma config file being executed again, which has very bad side effects (all files would be loaded twice and such)
            this.runConfig = await karma_wrapper_1.karma.config.parseConfig(null, {
                hostname: stryker_reporter_1.StrykerReporter.instance.karmaConfig.hostname,
                port: stryker_reporter_1.StrykerReporter.instance.karmaConfig.port,
                listenAddress: stryker_reporter_1.StrykerReporter.instance.karmaConfig.listenAddress,
            });
        }
    }
    async dryRun(options) {
        test_hooks_middleware_1.TestHooksMiddleware.instance.configureCoverageAnalysis(options.coverageAnalysis);
        return await this.run();
    }
    async mutantRun(options) {
        test_hooks_middleware_1.TestHooksMiddleware.instance.configureMutantRun(options);
        stryker_reporter_1.StrykerReporter.instance.configureHitLimit(options.hitLimit);
        const dryRunResult = await this.run();
        return (0, test_runner_1.toMutantRunResult)(dryRunResult, true);
    }
    run() {
        const runPromise = stryker_reporter_1.StrykerReporter.instance.whenRunCompletes();
        this.runServer();
        return runPromise;
    }
    async dispose() {
        if (stryker_reporter_1.StrykerReporter.instance.karmaServer) {
            await stryker_reporter_1.StrykerReporter.instance.karmaServer.stop();
            await this.exitPromise;
        }
        stryker_reporter_1.StrykerReporter.instance.karmaServer = undefined;
        stryker_reporter_1.StrykerReporter.instance.karmaConfig = undefined;
    }
    loadSetup(options) {
        const defaultKarmaConfig = {
            projectType: 'custom',
        };
        return Object.assign(defaultKarmaConfig, options.karma);
    }
    runServer() {
        karma_wrapper_1.karma.runner.run(this.runConfig, (exitCode) => {
            this.log.debug('karma run done with ', exitCode);
        });
    }
}
exports.KarmaTestRunner = KarmaTestRunner;
KarmaTestRunner.inject = (0, plugin_1.tokens)(plugin_1.commonTokens.logger, plugin_1.commonTokens.getLogger, plugin_1.commonTokens.options);
//# sourceMappingURL=karma-test-runner.js.map